Raporty tabelaryczne w R
========================================================




Zapoznają się Państwo z raportami tabelarycznymi w R. Omówione zostaną funkcje:

* table, prop.table, xtabs, ftable, summary, by, aggregate

Dodatkowe pakiety przyśpieszające pracę z przetwarzaniem tabelarycznym:

* reshape2, dplyr, data.table

oraz pakiety do tworzenia "ładnych tabel"

* xtable, hwriter, sjPlot

1. Wczytanie danych. 
------------

Poniższy kod wcztuje dane Diagnozy Społecznej. Plik .RData zawiera trzy obiekty typu/klasy data.frame:
* dictionary -- zbiór zawiera nazwy zmiennych
* etykiety -- zbiór zawiera etykiety zmiennych
* gosp -- zbiór zawiera odpowiedzi respondentów na pytania zadane w diagnozie społecznej.


```r
### polecenie setwd ustala domyślny folder
setwd('C:/Zajecia/')

### polecenie load wczytuje pliki o rozszerzeniu RData
load('DiagnozaGosp.RData')
```





Następnie wykorzystamy podstawowe polecenia, które podsumuja wczytany zbiór danych. Poleceniem dim, nrow, ncol otrzymamy odpowiednio informację o wymiarach tabeli, liczbie wierszy oraz liczbie kolumn.


```r
dim(gosp)
```

```
[1] 23804  2109
```

```r
nrow(gosp)
```

```
[1] 23804
```

```r
ncol(gosp)
```

```
[1] 2109
```


Poleceniem head i tail możemy podejrzeć pierwsze i ostatnie 6 wierszy zbioru danych.


```r
head(dictionary)
```

```
              colName                                label LP
1            numer_gd 'Numer identyfikacyjny gospodarstwa'  1
2 nr_sztywny_15062013                              (none)   2
3         L_OSOB_2000 'liczba osób w gospodarstwie w 2000'  3
4         L_OSOB_2003 'liczba osób w gospodarstwie w 2003'  4
5         L_OSOB_2005 'liczba osób w gospodarstwie w 2005'  5
6         L_OSOB_2007 'liczba osób w gospodarstwie w 2007'  6
```

```r
tail(dictionary)
```

```
               colName                                             label   LP
2104              GGSE                          'Grupa społ.-ekon. 2013' 2104
2105            GNCU13                 'liczba jednostek ekwiwalentnych' 2105
2106     gdoch_m_osoba                         'dochód na osobę miesiąc' 2106
2107     gdoch_r_osoba                         'dochód na osobę miesiąc' 2107
2108 gdoch_r_osoba_ekw           'dochód na jed. ekwiwalentną w 2012 r.' 2108
2109 gdoch_m_osoba_ekw 'dochód na jed. ekwiwalentną w ostatnim miesiącu' 2109
```

Natomiast polecenie names zwraca nam nazwy kolumn.


```r
names(etykiety)
```

```
[1] "variable" "values"   "labels"   "label"    "LP"      
```


W ramach zajęć i pracy w R będziemy posiłkowali się zbiorami dictionary oraz etykiety w celu opisu danych numerycznych, które znajdują się w zbiorze gosp. 

2. Funkcja table
------------

Pierwszą funkcją, którą poznamy jest służy do tworzenia prostych podsumowań tabelarycznych. Możemy z jej pomocą tworzyć zestawienia jedno i wielowymiarowe. Funkcję **table** możemy wykorzystywać w przypadku gdy interesuje nas nieprzeważony wynik. W tym momencie załóżmy, że własnie z taką sytuacją mamy do czynienia. 

Istotnym funkcji argumentem jest *useNA*, który domyślnie przyjmuje wartość 'no' co oznacza, że braki danych nie będą wyświetlane w podsumowaniu.


```r
### składnia polecenia table
table(..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no",
    "ifany", "always"), dnn = list.names(...), deparse.level = 1)
```


Wykonajmny prostą tabelę częstości dla zmiennej WOJEWODZTWO. 

```r
table(gosp$WOJEWODZTWO,dnn='Województwa',useNA='ifany')
```

```
Województwa
   2    4    6    8   10   12   14   16   18   20   22   24   26   28   30   32 <NA> 
1870 1355 1429  786 1694 1719 2820  794 1254  883 1363 2740 1030 1068 1886 1112    1 
```


Wynik działania funkcji możemy przypisać do obiektu, poleceniem *str* możemy zobaczyć jego strukturę, a *class*  klasę.

```r
tab1<-table(gosp$WOJEWODZTWO,dnn='Województwa',useNA='ifany')
str(tab1)
```

```
 'table' int [1:17(1d)] 1870 1355 1429 786 1694 1719 2820 794 1254 883 ...
 - attr(*, "dimnames")=List of 1
  ..$ Województwa: chr [1:17] "2" "4" "6" "8" ...
```

```r
class(tab1)
```

```
[1] "table"
```


Jeżeli dla wielu zmiennych stworzyć oddzielne podsumowania musimy do każdej zmiennej oddzielnie zastosować funckję *table*. Warto skorzystać w tym miejscu z rodziny funkcji **apply*, a w szczególności z *lapply* oraz *sapply*.


```r
### możemy skorzystać z poniższego kodu:
table(gosp$WOJEWODZTWO)
```

```

   2    4    6    8   10   12   14   16   18   20   22   24   26   28   30   32 
1870 1355 1429  786 1694 1719 2820  794 1254  883 1363 2740 1030 1068 1886 1112 
```

```r
table(gosp$KLASA_MIEJSCOWOSCI)
```

```

   1    2    3    4    5    6 
2563 2551 2010 4953 3198 8524 
```

```r
### lub dla poszczególnych zmiennych wykorzystać rodzinę funkcji apply (wszystkie zwrócą ten sam wynik)
apply(gosp[,c('WOJEWODZTWO','KLASA_MIEJSCOWOSCI')],MARGIN=2,table)
```

```
$WOJEWODZTWO

   2    4    6    8   10   12   14   16   18   20   22   24   26   28   30   32 
1870 1355 1429  786 1694 1719 2820  794 1254  883 1363 2740 1030 1068 1886 1112 

$KLASA_MIEJSCOWOSCI

   1    2    3    4    5    6 
2563 2551 2010 4953 3198 8524 
```

```r
lapply(gosp[,c('WOJEWODZTWO','KLASA_MIEJSCOWOSCI')],table)
```

```
$WOJEWODZTWO

   2    4    6    8   10   12   14   16   18   20   22   24   26   28   30   32 
1870 1355 1429  786 1694 1719 2820  794 1254  883 1363 2740 1030 1068 1886 1112 

$KLASA_MIEJSCOWOSCI

   1    2    3    4    5    6 
2563 2551 2010 4953 3198 8524 
```

```r
sapply(gosp[,c('WOJEWODZTWO','KLASA_MIEJSCOWOSCI')],table)
```

```
$WOJEWODZTWO

   2    4    6    8   10   12   14   16   18   20   22   24   26   28   30   32 
1870 1355 1429  786 1694 1719 2820  794 1254  883 1363 2740 1030 1068 1886 1112 

$KLASA_MIEJSCOWOSCI

   1    2    3    4    5    6 
2563 2551 2010 4953 3198 8524 
```



Natomiast jeżeli interesuje nas stworzenie tablicy dwu i wielowymiarowej możemy wypisać poszczególne zmienne w funkcji table. W wyniku otrzymamy tabelę krzyżową dla określonych przekrojów.


```r
### podajemy dwa wymiary (1=wiersze,2=kolumny)
table(gosp$WOJEWODZTWO,gosp$KLASA_MIEJSCOWOSCI)
```

```
    
       1   2   3   4   5   6
  2  412   0 163 441 315 539
  4    0 365  96 176 227 490
  6    0 276   0 276 173 702
  8    0   0 205 133 193 255
  10 524   0   1 475 155 539
  12 438   1  61 225 196 798
  14 841 141  62 478 321 976
  16   1   0 141 175 159 318
  18   0   0 137 300 150 667
  20   0 243   0 191 123 326
  22   4 461  25 329 146 398
  24   9 570 679 686 180 616
  26   2 207  10 209 136 466
  28   0   1 270 211 202 384
  30 329   0  72 438 311 736
  32   3 286  88 210 211 314
```

```r
### lub równoważnie (przy czym automatycznie naniesone zostaną etykiety dla wierszy i kolumn)
table(gosp[,c('WOJEWODZTWO','KLASA_MIEJSCOWOSCI')])
```

```
           KLASA_MIEJSCOWOSCI
WOJEWODZTWO   1   2   3   4   5   6
         2  412   0 163 441 315 539
         4    0 365  96 176 227 490
         6    0 276   0 276 173 702
         8    0   0 205 133 193 255
         10 524   0   1 475 155 539
         12 438   1  61 225 196 798
         14 841 141  62 478 321 976
         16   1   0 141 175 159 318
         18   0   0 137 300 150 667
         20   0 243   0 191 123 326
         22   4 461  25 329 146 398
         24   9 570 679 686 180 616
         26   2 207  10 209 136 466
         28   0   1 270 211 202 384
         30 329   0  72 438 311 736
         32   3 286  88 210 211 314
```


W przypadku trzech i więcej wymiarów należy dodawać kolejne zmienne (po przecinku) w poleceniu table. UWAGA kolejność ma znaczenie przy wyświetlaniu wyników! Poniżej przedstawione są wyniki w podziale na zmienną F10. Czy Pana(i) gospodarstwo domowe ma obecnie do spłacenia pożyczki lub kredyty?, która przyjmuje wartości 1 dla TAK oraz 2 dla NIE.


```r
table(gosp[,c('WOJEWODZTWO','KLASA_MIEJSCOWOSCI','GF10')])
```

```
, , GF10 = 1

           KLASA_MIEJSCOWOSCI
WOJEWODZTWO   1   2   3   4   5   6
         2   84   0  37  87  58 112
         4    0  62  17  23  39  91
         6    0  47   0  51  35 158
         8    0   0  39  27  37  57
         10  95   0   0  86  20 115
         12  63   0   9  28  22 128
         14 138  21  12  77  41 189
         16   0   0  25  38  30  56
         18   0   0   8  40  24 113
         20   0  32   0  29  23  60
         22   1  90   0  71  35 100
         24   1  77 148 139  31 119
         26   0  28   2  13  19  94
         28   0   0  55  38  33  86
         30  52   0   7  64  56 157
         32   0  40  11  32  36  60

, , GF10 = 2

           KLASA_MIEJSCOWOSCI
WOJEWODZTWO   1   2   3   4   5   6
         2   90   0  40 128 106 158
         4    0  83  21  47  67 203
         6    0  74   0  96  56 292
         8    0   0  61  38  54  79
         10 150   0   1 136  56 209
         12 139   1  16  72  70 347
         14 193  59  20 156 101 423
         16   0   0  32  44  49 131
         18   0   0  31  94  50 329
         20   0  92   0  68  41 143
         22   1 117   2  91  54 130
         24   0 154 209 230  65 259
         26   1  54   7  91  57 212
         28   0   1  70  71  77 162
         30  79   0  19 158  92 262
         32   0  75  17  65  62  98
```


Funkcja *table* domyślnie zwraca wartości liczbowe. Jeżeli chcielibyśmy otrzymać wyniki w procentach musimy zastosować funkcję *prop.table*. 


```r
tab1<-table(gosp[,c('WOJEWODZTWO','KLASA_MIEJSCOWOSCI')])
### procent z ogółu
prop.table(tab1)
```

```
           KLASA_MIEJSCOWOSCI
WOJEWODZTWO         1         2         3         4         5         6
         2  1.731e-02 0.000e+00 6.849e-03 1.853e-02 1.324e-02 2.265e-02
         4  0.000e+00 1.534e-02 4.034e-03 7.395e-03 9.538e-03 2.059e-02
         6  0.000e+00 1.160e-02 0.000e+00 1.160e-02 7.269e-03 2.950e-02
         8  0.000e+00 0.000e+00 8.614e-03 5.588e-03 8.110e-03 1.071e-02
         10 2.202e-02 0.000e+00 4.202e-05 1.996e-02 6.513e-03 2.265e-02
         12 1.840e-02 4.202e-05 2.563e-03 9.454e-03 8.236e-03 3.353e-02
         14 3.534e-02 5.925e-03 2.605e-03 2.008e-02 1.349e-02 4.101e-02
         16 4.202e-05 0.000e+00 5.925e-03 7.353e-03 6.681e-03 1.336e-02
         18 0.000e+00 0.000e+00 5.757e-03 1.261e-02 6.303e-03 2.803e-02
         20 0.000e+00 1.021e-02 0.000e+00 8.026e-03 5.168e-03 1.370e-02
         22 1.681e-04 1.937e-02 1.050e-03 1.382e-02 6.135e-03 1.672e-02
         24 3.782e-04 2.395e-02 2.853e-02 2.882e-02 7.563e-03 2.588e-02
         26 8.404e-05 8.698e-03 4.202e-04 8.782e-03 5.715e-03 1.958e-02
         28 0.000e+00 4.202e-05 1.135e-02 8.866e-03 8.488e-03 1.614e-02
         30 1.382e-02 0.000e+00 3.025e-03 1.840e-02 1.307e-02 3.093e-02
         32 1.261e-04 1.202e-02 3.698e-03 8.824e-03 8.866e-03 1.319e-02
```

```r
### margin=1, procent z wiersza
prop.table(tab1,margin=1)
```

```
           KLASA_MIEJSCOWOSCI
WOJEWODZTWO         1         2         3         4         5         6
         2  0.2203209 0.0000000 0.0871658 0.2358289 0.1684492 0.2882353
         4  0.0000000 0.2695716 0.0709010 0.1299852 0.1676514 0.3618907
         6  0.0000000 0.1934128 0.0000000 0.1934128 0.1212334 0.4919411
         8  0.0000000 0.0000000 0.2608142 0.1692112 0.2455471 0.3244275
         10 0.3093270 0.0000000 0.0005903 0.2804014 0.0914994 0.3181818
         12 0.2547993 0.0005817 0.0354857 0.1308901 0.1140198 0.4642234
         14 0.2983327 0.0500177 0.0219936 0.1695637 0.1138702 0.3462221
         16 0.0012594 0.0000000 0.1775819 0.2204030 0.2002519 0.4005038
         18 0.0000000 0.0000000 0.1092504 0.2392344 0.1196172 0.5318979
         20 0.0000000 0.2751982 0.0000000 0.2163080 0.1392978 0.3691959
         22 0.0029347 0.3382245 0.0183419 0.2413793 0.1071167 0.2920029
         24 0.0032847 0.2080292 0.2478102 0.2503650 0.0656934 0.2248175
         26 0.0019417 0.2009709 0.0097087 0.2029126 0.1320388 0.4524272
         28 0.0000000 0.0009363 0.2528090 0.1975655 0.1891386 0.3595506
         30 0.1744433 0.0000000 0.0381760 0.2322375 0.1648993 0.3902439
         32 0.0026978 0.2571942 0.0791367 0.1888489 0.1897482 0.2823741
```

```r
### margin=2, procent z kolumny
prop.table(tab1,margin=2)
```

```
           KLASA_MIEJSCOWOSCI
WOJEWODZTWO         1         2         3         4         5         6
         2  0.1607491 0.0000000 0.0810945 0.0890369 0.0984991 0.0632332
         4  0.0000000 0.1430811 0.0477612 0.0355340 0.0709819 0.0574847
         6  0.0000000 0.1081929 0.0000000 0.0557238 0.0540963 0.0823557
         8  0.0000000 0.0000000 0.1019900 0.0268524 0.0603502 0.0299155
         10 0.2044479 0.0000000 0.0004975 0.0959015 0.0484678 0.0632332
         12 0.1708935 0.0003920 0.0303483 0.0454270 0.0612883 0.0936180
         14 0.3281311 0.0552724 0.0308458 0.0965072 0.1003752 0.1145002
         16 0.0003902 0.0000000 0.0701493 0.0353321 0.0497186 0.0373064
         18 0.0000000 0.0000000 0.0681592 0.0605694 0.0469043 0.0782496
         20 0.0000000 0.0952568 0.0000000 0.0385625 0.0384615 0.0382450
         22 0.0015607 0.1807134 0.0124378 0.0664244 0.0456535 0.0466917
         24 0.0035115 0.2234418 0.3378109 0.1385019 0.0562852 0.0722665
         26 0.0007803 0.0811446 0.0049751 0.0421966 0.0425266 0.0546692
         28 0.0000000 0.0003920 0.1343284 0.0426004 0.0631645 0.0450493
         30 0.1283652 0.0000000 0.0358209 0.0884313 0.0972483 0.0863444
         32 0.0011705 0.1121129 0.0437811 0.0423985 0.0659787 0.0368372
```

```r
### jeżeli chcemy otrzymać bardziej czytelne wyniki możemy pomnożyć wynik razy 100 i wykorzystac funkcję round w celu pokazania dwóch miejsc po przecinku
round(prop.table(tab1,margin=1)*100,2)
```

```
           KLASA_MIEJSCOWOSCI
WOJEWODZTWO     1     2     3     4     5     6
         2  22.03  0.00  8.72 23.58 16.84 28.82
         4   0.00 26.96  7.09 13.00 16.77 36.19
         6   0.00 19.34  0.00 19.34 12.12 49.19
         8   0.00  0.00 26.08 16.92 24.55 32.44
         10 30.93  0.00  0.06 28.04  9.15 31.82
         12 25.48  0.06  3.55 13.09 11.40 46.42
         14 29.83  5.00  2.20 16.96 11.39 34.62
         16  0.13  0.00 17.76 22.04 20.03 40.05
         18  0.00  0.00 10.93 23.92 11.96 53.19
         20  0.00 27.52  0.00 21.63 13.93 36.92
         22  0.29 33.82  1.83 24.14 10.71 29.20
         24  0.33 20.80 24.78 25.04  6.57 22.48
         26  0.19 20.10  0.97 20.29 13.20 45.24
         28  0.00  0.09 25.28 19.76 18.91 35.96
         30 17.44  0.00  3.82 23.22 16.49 39.02
         32  0.27 25.72  7.91 18.88 18.97 28.24
```


Domyślnie funkcje nie zwracają marginesów, jeżeli chcemy je dodać to musimy zastosować funkcję *addmargins*, w której określamy marginesy określamy parametrem margin. Funkcja *addmargins* umożliwia również określenie funkcji, którą chcemy zastosować do podsumowań (domyślnie jest to suma).


```r
### suma wierszy i kolumn
addmargins(tab1)
```

```
           KLASA_MIEJSCOWOSCI
WOJEWODZTWO     1     2     3     4     5     6   Sum
        2     412     0   163   441   315   539  1870
        4       0   365    96   176   227   490  1354
        6       0   276     0   276   173   702  1427
        8       0     0   205   133   193   255   786
        10    524     0     1   475   155   539  1694
        12    438     1    61   225   196   798  1719
        14    841   141    62   478   321   976  2819
        16      1     0   141   175   159   318   794
        18      0     0   137   300   150   667  1254
        20      0   243     0   191   123   326   883
        22      4   461    25   329   146   398  1363
        24      9   570   679   686   180   616  2740
        26      2   207    10   209   136   466  1030
        28      0     1   270   211   202   384  1068
        30    329     0    72   438   311   736  1886
        32      3   286    88   210   211   314  1112
        Sum  2563  2551  2010  4953  3198  8524 23799
```

```r
### podsumowania dla kolumn
addmargins(tab1,margin=1)
```

```
           KLASA_MIEJSCOWOSCI
WOJEWODZTWO    1    2    3    4    5    6
        2    412    0  163  441  315  539
        4      0  365   96  176  227  490
        6      0  276    0  276  173  702
        8      0    0  205  133  193  255
        10   524    0    1  475  155  539
        12   438    1   61  225  196  798
        14   841  141   62  478  321  976
        16     1    0  141  175  159  318
        18     0    0  137  300  150  667
        20     0  243    0  191  123  326
        22     4  461   25  329  146  398
        24     9  570  679  686  180  616
        26     2  207   10  209  136  466
        28     0    1  270  211  202  384
        30   329    0   72  438  311  736
        32     3  286   88  210  211  314
        Sum 2563 2551 2010 4953 3198 8524
```

```r
### podsumowania dla wierszy
addmargins(tab1,margin=2)
```

```
           KLASA_MIEJSCOWOSCI
WOJEWODZTWO    1    2    3    4    5    6  Sum
         2   412    0  163  441  315  539 1870
         4     0  365   96  176  227  490 1354
         6     0  276    0  276  173  702 1427
         8     0    0  205  133  193  255  786
         10  524    0    1  475  155  539 1694
         12  438    1   61  225  196  798 1719
         14  841  141   62  478  321  976 2819
         16    1    0  141  175  159  318  794
         18    0    0  137  300  150  667 1254
         20    0  243    0  191  123  326  883
         22    4  461   25  329  146  398 1363
         24    9  570  679  686  180  616 2740
         26    2  207   10  209  136  466 1030
         28    0    1  270  211  202  384 1068
         30  329    0   72  438  311  736 1886
         32    3  286   88  210  211  314 1112
```


3. Funkcja xtabs
------------
Funkcja *xtable* jest przeznaczona do tworzenia tabel krzyżowych (dwu i wymiarowych). Składnia procedury jest nastepujaca:


```r
xtabs(formula = ~., data = parent.frame(), subset, sparse = FALSE,
      na.action, exclude = c(NA, NaN), drop.unused.levels = FALSE)
```


Pierwszym parametrem jest formuła, którą konstruuje się w następujący sposób -- po lewej stronie mogą znajdować się liczebności lub inne statystyki (nie jest to wymagane), a po prawej stronie zmienne (rozdzielone symbolem + ). Funkcję możemy zamiennie stosować z table, jak również w momencie gdy posiadamy liczebnosci lub inne statystyki opisowe i chcemy stworzyć na ich podstawie table. 

Funkcja umożliwia również zastosowanie tzw. macierzy rzadkich (ang. sparse matrix), które są przydatne gdy utworzone zestawienie zawiera puste przekroje (wartości 0).


```r
### podstawowa wartość
xtabs(~WOJEWODZTWO+KLASA_MIEJSCOWOSCI,data=gosp,sparse=F)
```

```
           KLASA_MIEJSCOWOSCI
WOJEWODZTWO   1   2   3   4   5   6
         2  412   0 163 441 315 539
         4    0 365  96 176 227 490
         6    0 276   0 276 173 702
         8    0   0 205 133 193 255
         10 524   0   1 475 155 539
         12 438   1  61 225 196 798
         14 841 141  62 478 321 976
         16   1   0 141 175 159 318
         18   0   0 137 300 150 667
         20   0 243   0 191 123 326
         22   4 461  25 329 146 398
         24   9 570 679 686 180 616
         26   2 207  10 209 136 466
         28   0   1 270 211 202 384
         30 329   0  72 438 311 736
         32   3 286  88 210 211 314
```

```r
### z wykorzystaniem macierzy rzadkich
xtabs(~WOJEWODZTWO+KLASA_MIEJSCOWOSCI,data=gosp,sparse=T)
```

```
16 x 6 sparse Matrix of class "dgCMatrix"
     1   2   3   4   5   6
2  412   . 163 441 315 539
4    . 365  96 176 227 490
6    . 276   . 276 173 702
8    .   . 205 133 193 255
10 524   .   1 475 155 539
12 438   1  61 225 196 798
14 841 141  62 478 321 976
16   1   . 141 175 159 318
18   .   . 137 300 150 667
20   . 243   . 191 123 326
22   4 461  25 329 146 398
24   9 570 679 686 180 616
26   2 207  10 209 136 466
28   .   1 270 211 202 384
30 329   .  72 438 311 736
32   3 286  88 210 211 314
```


Proszę zauważyć, że funkcja *xtabs* w wersji podstawowej ustawia nazwy zmiennych. Niestety, funkcja w przypadku większej liczby wymiarów zwraca wynik podobny jak *table*.

4. Funkcja ftable
------------

Jeżeli chcemy utworzyć tabelę wielowymiarową warto skorzystać z funkcji *ftable*. Tabelę możemy stworzyć na dwa sposoby, podając formułę lub numery kolumn dla których tworzymy zestawienie. Składnia procedury jest następująca:

* w przypadku podania formuły: kolumna1 + kolumna2 ... + kolumnaN ~ wiersz1 + wiersz2 + ... + wierszN
* w przypadku podania zbioru: argumenty row.vars oraz col.vars określają układ tabeli. Podane muszą zostać wektory numeryczne, a kolejność cyfr ma znaczenie. Poniżej przykład dla zmiennej GF10 (F10. Czy Pana(i) gospodarstwo domowe ma obecnie do spłacenia pożyczki lub kredyty?, która przyjmuje wartości 1 dla TAK oraz 2 dla NIE).


```r
ftable(WOJEWODZTWO~GF10+KLASA_MIEJSCOWOSCI,data=gosp)
```

```
                        WOJEWODZTWO   2   4   6   8  10  12  14  16  18  20  22  24  26  28  30  32
GF10 KLASA_MIEJSCOWOSCI                                                                            
1    1                               84   0   0   0  95  63 138   0   0   0   1   1   0   0  52   0
     2                                0  62  47   0   0   0  21   0   0  32  90  77  28   0   0  40
     3                               37  17   0  39   0   9  12  25   8   0   0 148   2  55   7  11
     4                               87  23  51  27  86  28  77  38  40  29  71 139  13  38  64  32
     5                               58  39  35  37  20  22  41  30  24  23  35  31  19  33  56  36
     6                              112  91 158  57 115 128 189  56 113  60 100 119  94  86 157  60
2    1                               90   0   0   0 150 139 193   0   0   0   1   0   1   0  79   0
     2                                0  83  74   0   0   1  59   0   0  92 117 154  54   1   0  75
     3                               40  21   0  61   1  16  20  32  31   0   2 209   7  70  19  17
     4                              128  47  96  38 136  72 156  44  94  68  91 230  91  71 158  65
     5                              106  67  56  54  56  70 101  49  50  41  54  65  57  77  92  62
     6                              158 203 292  79 209 347 423 131 329 143 130 259 212 162 262  98
```

```r
ftable(gosp[,c('WOJEWODZTWO','GF10','KLASA_MIEJSCOWOSCI')],data=gosp,row.vars=c(2,3),col.vars=1)
```

```
                        WOJEWODZTWO   2   4   6   8  10  12  14  16  18  20  22  24  26  28  30  32
GF10 KLASA_MIEJSCOWOSCI                                                                            
1    1                               84   0   0   0  95  63 138   0   0   0   1   1   0   0  52   0
     2                                0  62  47   0   0   0  21   0   0  32  90  77  28   0   0  40
     3                               37  17   0  39   0   9  12  25   8   0   0 148   2  55   7  11
     4                               87  23  51  27  86  28  77  38  40  29  71 139  13  38  64  32
     5                               58  39  35  37  20  22  41  30  24  23  35  31  19  33  56  36
     6                              112  91 158  57 115 128 189  56 113  60 100 119  94  86 157  60
2    1                               90   0   0   0 150 139 193   0   0   0   1   0   1   0  79   0
     2                                0  83  74   0   0   1  59   0   0  92 117 154  54   1   0  75
     3                               40  21   0  61   1  16  20  32  31   0   2 209   7  70  19  17
     4                              128  47  96  38 136  72 156  44  94  68  91 230  91  71 158  65
     5                              106  67  56  54  56  70 101  49  50  41  54  65  57  77  92  62
     6                              158 203 292  79 209 347 423 131 329 143 130 259 212 162 262  98
```


Jak możemy zawuważyć wyniki są równoważne. Dodatkowo, jeżeli podamy zmienne poprzez wykorzystanie $ możemy nadać własne nazwy zmiennych.


```r
ftable(gosp$WOJEWODZTWO,gosp$GF10,gosp$KLASA_MIEJSCOWOSCI,row.vars=c(2,3),col.vars=1,
       dnn=c('Województwo','Kredyt','KLM'))
```

```
           Województwo   2   4   6   8  10  12  14  16  18  20  22  24  26  28  30  32
Kredyt KLM                                                                            
1      1                84   0   0   0  95  63 138   0   0   0   1   1   0   0  52   0
       2                 0  62  47   0   0   0  21   0   0  32  90  77  28   0   0  40
       3                37  17   0  39   0   9  12  25   8   0   0 148   2  55   7  11
       4                87  23  51  27  86  28  77  38  40  29  71 139  13  38  64  32
       5                58  39  35  37  20  22  41  30  24  23  35  31  19  33  56  36
       6               112  91 158  57 115 128 189  56 113  60 100 119  94  86 157  60
2      1                90   0   0   0 150 139 193   0   0   0   1   0   1   0  79   0
       2                 0  83  74   0   0   1  59   0   0  92 117 154  54   1   0  75
       3                40  21   0  61   1  16  20  32  31   0   2 209   7  70  19  17
       4               128  47  96  38 136  72 156  44  94  68  91 230  91  71 158  65
       5               106  67  56  54  56  70 101  49  50  41  54  65  57  77  92  62
       6               158 203 292  79 209 347 423 131 329 143 130 259 212 162 262  98
```


5. Funkcja summary
------------

Funkcja *summary* zwraca podstaowe statystyki opisowe oraz podsumowania zmiennych tekstowych. Służy do pierwszego zapoznania się z danymi, zwłaszcza w kontekście weryfikacji liczby braków danych. Poniżej zastosowanie funkcji do zmiennej ciąglej .


```r
summary(gosp$gdoch_m_osoba)
```

```
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's 
     33     700    1080    1230    1500   17300   12361 
```


Natomiast jeżeli zastosujemy funkcję summary do zmiennej typu factor otrzymamy w wyniku następujący wydruk.


```r
summary(as.factor(gosp$L.OSOB_2013))
```

```
    1     2     3     4     5     6     7     8     9    10    11    12    13    14  NA's 
 2081  3376  2327  2261  1153   637   281   136    59    22    12     8     1     1 11449 
```


Nie zawsze zastosowanie funkcji *summary* skutkuje podobnym rezultatem. W przypadku zastosowania *summary* na funkcji *table* otrzymujemy następujący wynik:


```r
summary(table(gosp$WOJEWODZTWO))
```

```
Number of cases in table: 23803 
Number of factors: 1 
```


W przypadku dwuwymiarowej tabeli, dostajemy następujący rezultat. Otrzymujemy wyniki testu ChiKwadrat.


```r
summary(table(gosp$WOJEWODZTWO,gosp$GF10))
```

```
Number of cases in table: 12269 
Number of factors: 2 
Test for independence of all factors:
	Chisq = 111, df = 15, p-value = 9e-17
```


Podoba sytuacja występuje gdy stosujemy *summary* do wyniku funkcji *xtabs*.


```r
summary(xtabs(~WOJEWODZTWO+GF10,data=gosp))
```

```
Call: xtabs(formula = ~WOJEWODZTWO + GF10, data = gosp)
Number of cases in table: 12269 
Number of factors: 2 
Test for independence of all factors:
	Chisq = 111, df = 15, p-value = 9e-17
```


Pojawia się pytanie: kiedy mamy wiedzieć jaki rezultat otrzymamy po wpisaniu *summary*? W **R** wszystko jest obiektem, a (prawie) każdy obiekt ma metody, które można na nich stosować. Jedną z takich metod jest summary. Wpisując kod *methods(<funkcja>)* możemy zobaczyć do jakich obietów (dokładnie obiektów klasy S3) istnieją metody. Zapis jest następujący <funkcja>.<obiekt> (w przypadku obiektów S3).


```r
methods('summary')
```

```
 [1] summary.aov             summary.aovlist         summary.aspell*         summary.connection      summary.data.frame      summary.Date            summary.default         summary.ecdf*           summary.factor          summary.glm             summary.infl            summary.lm              summary.loess*          summary.manova          summary.matrix          summary.mlm             summary.nls*            summary.packageStatus*  summary.PDF_Dictionary* summary.PDF_Stream*     summary.POSIXct         summary.POSIXlt         summary.ppr*            summary.prcomp*         summary.princomp*       summary.proc_time       summary.shingle*        summary.srcfile         summary.srcref         
[30] summary.stepfun         summary.stl*            summary.table           summary.trellis*        summary.tukeysmooth*   

   Non-visible functions are asterisked
```


Jeżeli chcemy poznać jakie metody przypisane są do danego obiektu klasy S3 możemy zastosować funkcję methods ale wskazać, argumentem class, że chcemy dowiedzieć się o metodach przypisanych do tej klasy.


```r
methods(class='table')
```

```
 [1] aperm.table         as.data.frame.table Axis.table*         head.table*         lines.table*        melt.table          plot.table*         points.table*       print.table         summary.table       tail.table*        

   Non-visible functions are asterisked
```


6. Funkcje agregujące -- aggregate, by oraz tapply
------------
Niektóre operacje chcemy wykonywać na grupach. Domyślnie w R są trzy funkcje, które służą do grupowych podsumowań:

* aggregate -- funkcja służąca do podsumowań, zwraca w wyniku obiekt klasy data.frame.
* by -- funkcja do agregowania ale również do wykonywania obliczeń w podziale na grupy.
* tapply -- najbardziej "uboga" funkcja, która umożliwia generowanie podsumowań grupowych.


W pierwszej kolejności zajmiemy się funkcją aggregate. Składnia funkcji jest następuąca:


```r
aggregate(formula, data, FUN, ...,
          subset, na.action = na.omit)
```


Składnia formuły jest następująca:

*zmienna ciągła ~ zmienna agregujaca1 + zmienna agregująca2 + ... + zmienna agregującaN*

W przypadku gdy interesuje nas podsumowanie więcej niż jednej zmiennej,  formuła musi mieć następującą postać:

*cbind(zmienna ciągła1,zmienna ciągła2,..zmienna ciągłaN) ~ zmienna agregujaca1 + zmienna agregująca2 + ... + zmienna agregującaN*.

Przeprowadzimy następującą agregację: obliczymy średni dochód na jed. ekwiwalentną w 2012 r. (gdoch_r_osoba_ekw)


```r
agr<-aggregate(gdoch_r_osoba_ekw~WOJEWODZTWO+KLASA_MIEJSCOWOSCI,data=gosp,FUN=mean)
head(agr)
```

```
  WOJEWODZTWO KLASA_MIEJSCOWOSCI gdoch_r_osoba_ekw
1           2                  1            1862.7
2          10                  1            1742.6
3          12                  1            2040.2
4          14                  1            2845.3
5          22                  1            1742.5
6          24                  1             945.9
```


Natomiast jeżeli chcemy policzyć więcej statystyk musimy w argumencie FUN zadeklarować własną funkcję.


```r
agr<-aggregate(gdoch_r_osoba_ekw~WOJEWODZTWO+KLASA_MIEJSCOWOSCI,data=gosp,
          FUN=function(x) c(Srednia=mean(x),N=length(x)))
head(agr)
```

```
  WOJEWODZTWO KLASA_MIEJSCOWOSCI gdoch_r_osoba_ekw.Srednia gdoch_r_osoba_ekw.N
1           2                  1                    1862.7               157.0
2          10                  1                    1742.6               232.0
3          12                  1                    2040.2               179.0
4          14                  1                    2845.3               298.0
5          22                  1                    1742.5                 2.0
6          24                  1                     945.9                 1.0
```


Zagregujemy teraz dwie zmienne z wykorzystaniem cbind. Drugą zmienną będzie dochód z poprzedniego badania (póki co zakładamy, że nie wykorzystujemy wag). 


```r
agr<-aggregate(cbind(fdoch_r_osoba_ekw,gdoch_r_osoba_ekw)~WOJEWODZTWO+KLASA_MIEJSCOWOSCI,
          data=gosp,FUN=mean)
head(agr)
```

```
  WOJEWODZTWO KLASA_MIEJSCOWOSCI fdoch_r_osoba_ekw gdoch_r_osoba_ekw
1           2                  1              1945              1868
2          10                  1              1837              1674
3          12                  1              1924              2008
4          14                  1              2748              2839
5          26                  1              1203             11563
6          30                  1              2135              2214
```


i z własną funkcją


```r
agr<-aggregate(cbind(fdoch_r_osoba_ekw,gdoch_r_osoba_ekw)~WOJEWODZTWO+KLASA_MIEJSCOWOSCI,
          data=gosp,FUN=function(x) c(Srednia=mean(x),N=length(x)))
head(agr)
```

```
  WOJEWODZTWO KLASA_MIEJSCOWOSCI fdoch_r_osoba_ekw.Srednia fdoch_r_osoba_ekw.N gdoch_r_osoba_ekw.Srednia gdoch_r_osoba_ekw.N
1           2                  1                      1945                  98                      1868                  98
2          10                  1                      1837                 179                      1674                 179
3          12                  1                      1924                 127                      2008                 127
4          14                  1                      2748                 198                      2839                 198
5          26                  1                      1203                   1                     11563                   1
6          30                  1                      2135                  65                      2214                  65
```


Proszę jednak zauważyć, że wyniki moą się różnić ponieważ w tym przypadku brane są pod uwagę osoby, które brały udział w obydwu badaniach!!!


7. Funkcja dcast(reshape2)
------------

Funkcja *cast (dcast oraz acast) służy do tworzenia podsumowań tabelarycznych. Stworzona jest przez Pana Hadleya Wickham'a, który oprócz tego pakietu stworzył m.in. ggplot2, plyr, dplyr i jest jednym z odpowiedzialnych za powstanie RStudio.

Na zajęciach zajmiemy się funkcją *dcast*, którą wykorzystamy do stworzenia podsumowań. *dcast* ma następującą składnię:


```r
dcast(data, formula, fun.aggregate, ... , margins, subset,
      fill, drop, value.var)
```


Argumenty oznaczają:

* data -- zbiór danych typu data.frame, który ma tak zwany układ long (ang. *molten data frame*)
* formula	-- formuła, która określa sposób podsumowań.
* fun.aggregate	- funkcja agregująca, domyslnie przyjmuje wartość length (zliczanie wartości) 
* ...	--- argumenty, które przekazujemy funkcji agregującej
* margins	-- wskazujemy czy chcemy otrzymać podsumowania wierszy, kolumn lub obydwu na raz. Wskazujemy je poprzez nazwy albo TRUE
* subset	-- wskazujemy podzbiór na którym chcemy pracować (np. subset = .(variable=="length")) 
* fill -- wskazujemy co chcemy zrobić z brakami danych (czym mamy je wypełnić, domyślnie wartośc 0)
* drop	-- wskazujemy czy chcemy usunąć lub zostawić przekroje o zerowych liczebnościach
* value.var	-- wskazujemy zmienną, która przetrzymuje wartości 

Wykorzystamy poprzednie typy raportów do zestawień. Przy czym żeby zastosować funkcję dcast należy najpierw przekształcić zbiór danych stosując funkcję *melt*, której składnia znajduje się poniżej.


```r
melt(data, id.vars, measure.vars,
    variable.name = "variable", ..., na.rm = FALSE,
    value.name = "value")
```


* id.vars -- oznacza zmienne, które stosujemy do identyfikacji rekordów (najczęściej są to zmienne, które później będą tworzyły wiersze i kolumny tabeli)
* measure.vars -- oznacza zmienne, które chcemy zostawić w zbiorze danych. Domyślnie zostawione zostaną wszystkie zmienne, które znajdują się w zbiorze danych i nie zostały określone w id.vars
* variable.name -- określa nazwę zmiennej, która będzie przetrzymywała zmienne określone w measure.vars
* value.name -- określa zmienną, która będzie przetrzymywała wartości zmiennych określonych w measure.vars
* na.rm -- określa co możemy zrobić z brakami danych znajdującymi się w zmiennych określonych w measure.vars

Znając już podstaowe funkcje, przejdziemy do ich wykorzystania. W pierwszym kroku przetworzymy zbiór danych tak aby dostać zestawienie liczby reprezentantów w poszczególnych próbach. W pierwszym przypadku niezastosujemy wag, w drugim już zastosujemy i porównamy wyniki.


```r
library(reshape2)
dataMelted<-melt(id.vars=c('WOJEWODZTWO','KLASA_MIEJSCOWOSCI'),measure.vars='WAGA_GD_2013',data=gosp,na.rm=T)
head(dataMelted)
```

```
  WOJEWODZTWO KLASA_MIEJSCOWOSCI     variable  value
1          12                  5 WAGA_GD_2013 0.7866
2          24                  3 WAGA_GD_2013 0.8897
3          12                  5 WAGA_GD_2013 2.4135
4          12                  6 WAGA_GD_2013 0.2767
5          14                  6 WAGA_GD_2013 1.5481
6          14                  4 WAGA_GD_2013 0.5276
```

```r
dim(dataMelted)
```

```
[1] 12355     4
```


Teraz zastosujemy funkcję *dcast*.


```r
### liczebności nieprzeważone
dcast(dataMelted,WOJEWODZTWO~KLASA_MIEJSCOWOSCI,length,margins=T)
```

```
   WOJEWODZTWO    1    2   3    4    5    6 NA (all)
1            2  177    0  78  216  164  270  0   905
2            4    0  147  38   70  108  295  0   658
3            6    0  122   0  148   92  451  2   815
4            8    0    0 100   66   92  137  0   395
5           10  246    0   1  227   76  326  0   876
6           12  205    1  25  101   92  477  0   901
7           14  333   83  32  233  142  613  1  1437
8           16    0    0  57   82   79  188  0   406
9           18    0    0  39  135   75  443  0   692
10          20    0  126   0   97   64  205  0   492
11          22    2  207   2  162   89  230  0   692
12          24    1  233 358  370   96  383  0  1441
13          26    1   82   9  109   79  307  0   587
14          28    0    1 130  110  111  252  0   604
15          30  132    0  26  228  148  422  0   956
16          32    0  115  28   97   98  160  0   498
17       (all) 1097 1117 923 2451 1605 5159  3 12355
```

```r
### liczebności przeważone
dcast(dataMelted,WOJEWODZTWO~KLASA_MIEJSCOWOSCI,sum,margins=T)
```

```
   WOJEWODZTWO         1         2         3       4       5      6    NA   (all)
1            2  265.0842    0.0000   89.8211  238.84  155.15  250.1 0.000   999.0
2            4    0.0000  213.5160   43.9784   85.62   96.73  221.2 0.000   661.1
3            6    0.0000  143.0055    0.0000  125.21   74.03  326.5 1.383   670.1
4            8    0.0000    0.0000   92.6785   61.62   70.98  106.1 0.000   331.4
5           10  318.7133    0.0000    0.3187  213.46   63.64  256.3 0.000   852.5
6           12  319.4578    0.0000   33.7656  110.13   96.80  427.7 0.000   987.9
7           14  703.5376  101.7239   44.1666  258.56  146.99  525.4 0.000  1780.4
8           16    0.0000    0.0000   49.8435   73.13   67.00  127.3 0.000   317.3
9           18    0.0000    0.0000   51.1293  153.26   80.15  309.5 0.000   594.0
10          20    0.0000  103.8113    0.0000   84.42   52.67  134.2 0.000   375.1
11          22    1.8176  252.4773    4.5171  182.53   84.80  211.2 0.000   737.3
12          24    0.9305  302.4432  469.8934  419.53   91.59  294.7 0.000  1579.1
13          26    0.4024   58.5142   10.0177   70.31   55.01  194.1 0.000   388.3
14          28    0.0000    0.6569  123.0060   94.66   84.15  167.5 0.000   469.9
15          30  198.1891    0.0000   31.2533  251.81  167.10  382.6 0.000  1031.0
16          32    0.0000  169.6554   34.0363  107.40  104.12  164.4 0.000   579.6
17       (all) 1808.1323 1345.8037 1078.4255 2530.49 1490.93 4098.8 1.383 12354.0
```


Warto liczebności przeważone zaokrąglić i spróbujmy zapisać wyniki do obiektu. Następnie sprawdzimy jakiej klasy jest ten obiekt.


```r
dcast(dataMelted,WOJEWODZTWO~KLASA_MIEJSCOWOSCI,fun.aggregate=function(x) round(sum(x)))
```

```
   WOJEWODZTWO   1   2   3   4   5   6 NA
1            2 265   0  90 239 155 250  0
2            4   0 214  44  86  97 221  0
3            6   0 143   0 125  74 327  1
4            8   0   0  93  62  71 106  0
5           10 319   0   0 213  64 256  0
6           12 319   0  34 110  97 428  0
7           14 704 102  44 259 147 525  0
8           16   0   0  50  73  67 127  0
9           18   0   0  51 153  80 309  0
10          20   0 104   0  84  53 134  0
11          22   2 252   5 183  85 211  0
12          24   1 302 470 420  92 295  0
13          26   0  59  10  70  55 194  0
14          28   0   1 123  95  84 167  0
15          30 198   0  31 252 167 383  0
16          32   0 170  34 107 104 164  0
```

```r
n2013<-dcast(dataMelted,WOJEWODZTWO~KLASA_MIEJSCOWOSCI,fun.aggregate=function(x) round(sum(x)))
class(n2013)
```

```
[1] "data.frame"
```


Warto zauważyć, że obiekt jest klasy *data.frame*. Co to dla Nas oznacza? Możemy ten zbiór danych wykorzystać. Policzmy w takim razie, które przekroje są bardziej, a które mniej reprezentowane (stosunek liczebności przeważonej do nieprzeważnej). **Uwaga**, funkcja domyślnie szuka kolumny o nazwie values i na niej przeprowadza działania (lub ostatniej kolumny w zbiorze danych).


```r
n2013<-dcast(dataMelted,WOJEWODZTWO~KLASA_MIEJSCOWOSCI,length)
nw2013<-dcast(dataMelted,WOJEWODZTWO~KLASA_MIEJSCOWOSCI,sum)
por2013<-nw2013/n2013
por2013[is.na(por2013)]<-0
por2013<-round(por2013,2)
por2013$WOJEWODZTWO<-n2013$WOJEWODZTWO
por2013
```

```
   WOJEWODZTWO    1    2    3    4    5    6   NA
1            2 1.50 0.00 1.15 1.11 0.95 0.93 0.00
2            4 0.00 1.45 1.16 1.22 0.90 0.75 0.00
3            6 0.00 1.17 0.00 0.85 0.80 0.72 0.69
4            8 0.00 0.00 0.93 0.93 0.77 0.77 0.00
5           10 1.30 0.00 0.32 0.94 0.84 0.79 0.00
6           12 1.56 0.00 1.35 1.09 1.05 0.90 0.00
7           14 2.11 1.23 1.38 1.11 1.04 0.86 0.00
8           16 0.00 0.00 0.87 0.89 0.85 0.68 0.00
9           18 0.00 0.00 1.31 1.14 1.07 0.70 0.00
10          20 0.00 0.82 0.00 0.87 0.82 0.65 0.00
11          22 0.91 1.22 2.26 1.13 0.95 0.92 0.00
12          24 0.93 1.30 1.31 1.13 0.95 0.77 0.00
13          26 0.40 0.71 1.11 0.65 0.70 0.63 0.00
14          28 0.00 0.66 0.95 0.86 0.76 0.66 0.00
15          30 1.50 0.00 1.20 1.10 1.13 0.91 0.00
16          32 0.00 1.48 1.22 1.11 1.06 1.03 0.00
```

```r
### ile jest powyżej 1
sum(por2013[,2:ncol(por2013)]>1)
```

```
[1] 36
```


Jaki wniosek z powyższej tabeli? 36 elementów z badanych przekrojów była mniej niedoreprezentowana w badaniu w związku z tym otrzymała wyższe wagi (wartości powyżej 1). 

Wykorzystamy powyższą wiedzę do stworzenia tabeli, która zawierać będzie wagi z lat 2011 i 2013. Wykonamy te obliczenia w przekroju województw aby dowiedzieć się, które z nich zwiększyły swoją reprezentację.


```r
gosp11<-melt(data=gosp[,c('WOJEWODZTWO','WAGA_GD_2011')],id.vars=c('WOJEWODZTWO'),na.rm=T)
gosp13<-melt(data=gosp[,c('WOJEWODZTWO','WAGA_GD_2013')],id.vars=c('WOJEWODZTWO'),na.rm=T)
gosp11_13<-rbind(gosp11,gosp13)
dim(gosp11_13)
```

```
[1] 33003     3
```

```r

### lub równoważnie (a raczej krócej) możemy zastosować funkcję melt z pakietu reshape
library(reshape)
oldgosp11_13<-reshape::melt(data=gosp[,c('WOJEWODZTWO','WAGA_GD_2013','WAGA_GD_2011')],id.vars=c('WOJEWODZTWO'),na.rm=T)
dim(oldgosp11_13)
```

```
[1] 33003     3
```


Następnie przeprowadzimy analizę dwóch zmiennych i zestawimy je w jednej tabeli.


```r
dcast(gosp11_13,WOJEWODZTWO~variable,sum)
```

```
   WOJEWODZTWO WAGA_GD_2011 WAGA_GD_2013
1            2        976.0        999.0
2            4        648.8        661.1
3            6        676.6        670.1
4            8        314.2        331.4
5           10        884.9        852.5
6           12        980.1        987.9
7           14       1824.4       1780.4
8           16        325.5        317.3
9           18        577.2        594.0
10          20        374.5        375.1
11          22        724.5        737.3
12          24       1640.2       1579.1
13          26        395.0        388.3
14          28        450.3        469.9
15          30       1025.9       1031.0
16          32        568.9        579.6
17          NA          0.0          0.0
```

```r
wynik<-dcast(gosp11_13,WOJEWODZTWO~variable,sum)
```





8. Dodanie etykiet do wyników
------------

Do tej pory nie zajmowaliśmy się nadawaniem etykiet dla wyników. W celu nadania etykiet dla wartości możemy skorzystac z funkcji factor lub z atrybutów zapisanej tabeli. Należy jednak uważać ponieaż klasa typu factor może na początku korzystania przyczynić się do bólu główy (zwłaszcza jak chcemy wrócić do wartości pierwotnych). O to przykład


```r
### tworzymy wektor
wektor<-c(-1,0,1)
wektor
```

```
[1] -1  0  1
```

```r
### zamieniamy go funkcją as factor (bez etykiet)
wektor<-as.factor(wektor)
wektor
```

```
[1] -1 0  1 
Levels: -1 0 1
```

```r
### tworzymy na jego podstawie wektor typu factor
wektor<-factor(wektor,levels=c(-1,0,1),labels=c('B/D','TAK','NIE'))
wektor
```

```
[1] B/D TAK NIE
Levels: B/D TAK NIE
```

```r
### teraz chcemy wrócić do wartości prawdziwych i pojawia się problem (otrzymujemy wartości 1,2,3 a nie -1,0,1)
as.numeric(wektor)
```

```
[1] 1 2 3
```


W związku z tym należy uważać ponieważ funkcja factor zastepuje prawdziwe wartości w zbiorze danych kolejnymi liczbami naturalnymi. Polecam stosować etykiety dopiero na wyniku funkcji agregującej. Poniżej przykład jak zrobić to dla wyniku działania funkcji *xtabs*.


```r
### wywołanie funkcji xtable
xtabs(~WOJEWODZTWO+GF10,data=gosp)
```

```
           GF10
WOJEWODZTWO   1   2
         2  378 522
         4  232 421
         6  291 520
         8  160 232
         10 316 552
         12 250 645
         14 478 953
         16 149 256
         18 185 504
         20 144 344
         22 297 395
         24 515 917
         26 156 422
         28 212 381
         30 336 610
         32 179 317
```

```r
### wynik możemy przypisać do obiektu
tab<-xtabs(~WOJEWODZTWO+GF10,data=gosp)
### a jego wywołanie daje dokładnie taki sam wynik
tab
```

```
           GF10
WOJEWODZTWO   1   2
         2  378 522
         4  232 421
         6  291 520
         8  160 232
         10 316 552
         12 250 645
         14 478 953
         16 149 256
         18 185 504
         20 144 344
         22 297 395
         24 515 917
         26 156 422
         28 212 381
         30 336 610
         32 179 317
```


Teraz przejdzy do funckji *str* która umożliwi nam sprawdzenie, które elementy przetrzymują wartości 2,4,...,32 dla województwa, i 1,2 dla zmiennej gf10.


```r
str(tab)
```

```
 xtabs [1:16, 1:2] 378 232 291 160 316 250 478 149 185 144 ...
 - attr(*, "dimnames")=List of 2
  ..$ WOJEWODZTWO: chr [1:16] "2" "4" "6" "8" ...
  ..$ GF10       : chr [1:2] "1" "2"
 - attr(*, "class")= chr [1:2] "xtabs" "table"
 - attr(*, "call")= language xtabs(formula = ~WOJEWODZTWO + GF10, data = gosp)
```


Pojawia się słowo *attr(,"dimnames")*, które jest listą składającą się z dwóch obiektów (tego czego szukamy!!). Aby wyciągnąc te elementy możemy wywołać funkcję *attr*.


```r
### wywołanie funkcji attr
attr(tab,'dimnames')
```

```
$WOJEWODZTWO
 [1] "2"  "4"  "6"  "8"  "10" "12" "14" "16" "18" "20" "22" "24" "26" "28" "30" "32"

$GF10
[1] "1" "2"
```

```r
### odwołanie się do ementów wektora
attr(tab,'dimnames')$GF10
```

```
[1] "1" "2"
```

```r
### zmiana elementów wektora
attr(tab,'dimnames')$GF10<-c('Tak','Nie')
### wywołanie zmienionego obiektu
tab
```

```
           GF10
WOJEWODZTWO Tak Nie
         2  378 522
         4  232 421
         6  291 520
         8  160 232
         10 316 552
         12 250 645
         14 478 953
         16 149 256
         18 185 504
         20 144 344
         22 297 395
         24 515 917
         26 156 422
         28 212 381
         30 336 610
         32 179 317
```


Jak widać jest to bardzo proste :) zmieńmy teraz etykietę kolumny!


```r
### nazwy znajdują się w tym samym miejscu
names(attr(tab,'dimnames'))
```

```
[1] "WOJEWODZTWO" "GF10"       
```

```r
### wystarczy je teraz podmienić
names(attr(tab,'dimnames'))[2]<-'Czy Pana(i) gospodarstwo domowe ma obecnie do spłacenia pożyczki lub kredyty?'
tab
```

```
           Czy Pana(i) gospodarstwo domowe ma obecnie do spłacenia pożyczki lub kredyty?
WOJEWODZTWO Tak Nie
         2  378 522
         4  232 421
         6  291 520
         8  160 232
         10 316 552
         12 250 645
         14 478 953
         16 149 256
         18 185 504
         20 144 344
         22 297 395
         24 515 917
         26 156 422
         28 212 381
         30 336 610
         32 179 317
```


